* У коммита есть хэш - уникальный номер
* коммит - набор изменений в файлах и папках проекта, который сохранен в репозиторий под определенным именем. У коммита есть хэш - его идентификатор, дата, время, автор, коммент.


#НАСТРОЙКА
git --version
git config --global user.name "Sevelena"
git config --global user.email "sevelena11@gmail.com"
git config --list


#Клонирование проекта
git clone http://...

cd /папка проеката
git status - есть ли в папке проекта несохраненные изменения

#ДОБАВИТЬ внесенные изменения В РЕПОИЗИТОРИЙ (Git)
git add. - добавить ВСЕ изменения в текущей папке
git add <file>
git commit -m 'Комментарий, что изменялось'
 
#ДОБАВЛЕНИЕ ИЗМЕНЕНИЙ НА СЕРВЕР
git push -u origin master

#ИНИЦИАЛИЗИРОВАТЬ git-репозиторий в какой либо папке, перейдя в неё. После инициализации папки проекта в ней появляется специальная папка .git. В ней хранится вся история изменений.
git init

+
git status
git add .
git commit -m 'initial'

git show - показывает информацию о последнем коммите и его содержимом
q - выход из режима просмотра последнего коммита

git log - вся история коммитов
_____________________________________________________________________________________________________________
Файлы в папке, в кот. находится git репозиторий могут находиться в трех состояниях.
В коммит можно добавлять НЕ все измения, а только их часть

git status
1) Закоммичен (commited) ---> git commit -m 'Комментарий, что изменялось'
2) Изменен (not staged)
3) Готов к коммиту (staged) - называется "Добавление в индекс" ---> git add <file>


Команда git status позволяет просмотреть состояние рабочей директории — перечень незакоммиченных изменений: добавленных в индекс, непроиндексированных, не отслеживаемых в Git.

Индекс в Git
- это специальная область, в кот. хранятся изменения файлов, готовые к коммиту. Т.е. готовые к добавлению в репозиторий из рабочей папки


_________________________________________________________________________________________________________________________________________
ИГНОРИРОВАНИЕ ИЗМЕНЕНИЙ
имена файлов должны хранится в специальном файле .gitignore (создается вручную)
В файл .gitignore можно записывать имена файлов используя маску, например
*.log --- игнорируем все файлы проекта с расширением .log
logs/ --- игнорировать папку logs


Какие файлы не следует сохранять в репозитории?
- логи
- пользовательские файлы (аватарки, загруженные файлы, контент и-нет магазина)
- служебные файлы среды разработки
- внешние библиотеки
- файлы локальной конфигурации (н. файлы с настройками локального окружения)
- файлы операционной системы
- слишком большие файлы, которые не содержат програмный код

ОТРИЦАНИЕ ПАТТЕРНА
Если какой-то файл в папке игнорировать не следует, а нужно отслеживать
Например:
logs/*.log  #/ Исключаем все файлы с расширением log, лежащие в папке log
!logs/sample.log - продолжаем отслеживать sample.log, "!" - отрицание игнорирования



_________________________________________________________________________________________________________________________________________
2.2 Удалённые и локальные репозитории
git remote -v --- посмотреть путь к локальному репозиторию
git remote add origin [path]
git - название программы
remote - указание программе, что сейчас будет операция с настройками удаленных репозиториев
add - добавление новой записи в настройки
origin - название удаленного репозитория по умолчанию. (англ. "Источник", "Начало")
git push -u origin master --- отправляет локальный репозиторий на сервер. Параметр "-u" автоматически устанавливает связль между локальным и удаленным репозиторием таким образом, чтобы в дальнейшем можно было вызывать git push без дополнительных параметров. При первом выполнении передается имя репозитория и имя ветки (origin master)
git remote remove origin [path] --- удалит путь к удаленному репозиторию
git remote add origin [path]



_________________________________________________________________________________________________________________________________________
2.7 Внесение изменений и их отправка
git status
git add .
git commit -m 'message'
git push



_________________________________________________________________________________________________________________________________________
2.9 Обновление локального репозитория
git pull --- затянуть изменения с сервера
(!!!) Если над проектом работаете не только вы один, то всегда начинайте свою работу с команды git pull

Возможные ситуации:
1) Локальная версия == Удаленная версия (код совпадает
2) Локальная версия > Версия на сервере (локальная выше, т.е. внесены и закоммичены изменения, но не запушены на сервер)
3) Локальная версия < Версии на серверее (вы получили изменения, а затем кто-то запушил свои изменения => Версия на сервере стала выше вашей)
4) Конфликт версий (возможен, когда кто-то запушил свои изменения до вас и ваша версия локальная отличается от текущей версии на сервере)



_________________________________________________________________________________________________________________________________________
2.10 Разрешение конфликтов при обновлении репозитория
Конфликт - ситуация при которой на сервере в удаленном репозитории созданы одни коммиты, а у вас в локальном репозитории созданы другие.
Конфликты могут быть 2 видов:
- Простые --- разрешается автоматически. Примеры: изменения в разных файлах,
- Сложные --- можно разрешить только вручную (в одном файле, в одних и тех же строках)

git pull
Простой конфликт. Достаточно изменить только сообщение коммита, чтобы зафиксировать это слияние в истории изменениия
vi - редактор коммита по умолчанию. В нем можно изменить сообщение коммита
":wq" - выйти из vi. Команда сохраняет сообщение коммита
":q" - сообщение коммита по умолчанию + выход

pit push - после слияния коммитов залить новый комит со слиянием на сервер

Сложный конфликт => Нужно зайти в каждый файл, который гит не смог слить. и внести необходимые изменения. 



_________________________________________________________________________________________________________________________________________
ВЕТКИ
Позволяют работать команде над одними и теми же файлами одновременно

3.2 Ветки: создание и работа
git status - выводит в т.ч. и текущую ветку

СОЗДАТЬ ветку
git checkout -b name_of_the_branch
Параметр -b означает, что ветка новая и её нужно создать
(!) Новая ветка создается на основе текущей ветки


С помощью комманды git log можно посмотреть, в каких ветках присутствуют те или иные коммиты


ПЕРЕКЛЮЧИТЬСЯ между ветками
git checkout master --- переключение на master



_________________________________________________________________________________________________________________________________________
3.3 Работа с удалёнными ветками

Возможные кейсы:
1) Ветка создано локально,  в удаленном репозитории её нет
Решение: создать ветку с таким же именем как у локальной ветки в удаленном репозитории

git push --set-upstream origin %name-of-the-brunch%
аналогично (сокращенное написание)
git push -u origin %name-of-the-brunch%

Напоминание: origin --- имя удаленного репозитория (по умолчанию)

git remote -v --- список удаленных репозиториев, привязанных к локальному
git remote --- имя удаленного репозитория


2) Ветка есть на сервере, локально ветки нет
Решение: 
git pull

3) Ветки существуют и удаленно, и локально. Т.е. существуют и связаны
НО изменения внесены либо в одну,  либо в другую и их необходимо синхронизировать

git commit
git push

либо

git pull

___________________________
Список всех веток в репозитории:
git branch -a

зеленый цвет - локальная ветка
красный цвет - удаленный репозиторий



_________________________________________________________________________________________________________________________________________
3.5 Откладывание изменений

git stash --- сохранение внесенных изменений, которые не были закоммичены. также позволяет сохранять изменения добавленные в индексы. Сохраняются,
чтобы воспользоваться ими похже или перенести между ветками. Можно делать много наборов сохранений.
git stash list --- список наборов изменений, добавленных в stash
git stash pop --- возвращает изменения в текущую рабочую директорию. т.е. можно переключиться в другую ветку и вернуть изменния сохраненные в неё == перенос.
git stash drop N --- удаление ненужного стеша по его индексу

Принцип работы stash / stash pop

git stash ------> 0
git stash ------> 1
git stash ------> 2
git stash pop ------> 2
git stash pop ------> 1
git stash pop ------> 0



_________________________________________________________________________________________________________________________________________
3.7 Слияние веток