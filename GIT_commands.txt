* У коммита есть хэш - уникальный номер
* коммит - набор изменений в файлах и папках проекта, который сохранен в репозиторий под определенным именем. У коммита есть хэш - его идентификатор, дата, время, автор, коммент.


#НАСТРОЙКА
git --version
git config --global user.name "Sevelena"
git config --global user.email "sevelena11@gmail.com"
git config --list


#Клонирование проекта
git clone http://...

cd /папка проеката
git status - есть ли в папке проекта несохраненные изменения

#ДОБАВИТЬ внесенные изменения В РЕПОИЗИТОРИЙ (Git)
git add. - добавить ВСЕ изменения в текущей папке
git add <file>
git commit -m 'Комментарий, что изменялось'
 
#ДОБАВЛЕНИЕ ИЗМЕНЕНИЙ НА СЕРВЕР
git push -u origin master

#ИНИЦИАЛИЗИРОВАТЬ git-репозиторий в какой либо папке, перейдя в неё. После инициализации папки проекта в ней появляется специальная папка .git. В ней хранится вся история изменений.
git init

+
git status
git add .
git commit -m 'initial'

git show - показывает информацию о последнем коммите и его содержимом
q - выход из режима просмотра последнего коммита

git log - вся история коммитов
_____________________________________________________________________________________________________________
Файлы в папке, в кот. находится git репозиторий могут находиться в трех состояниях.
В коммит можно добавлять НЕ все измения, а только их часть

git status
1) Закоммичен (commited) ---> git commit -m 'Комментарий, что изменялось'
2) Изменен (not staged)
3) Готов к коммиту (staged) - называется "Добавление в индекс" ---> git add <file>


Команда git status позволяет просмотреть состояние рабочей директории — перечень незакоммиченных изменений: добавленных в индекс, непроиндексированных, не отслеживаемых в Git.

Индекс в Git
- это специальная область, в кот. хранятся изменения файлов, готовые к коммиту. Т.е. готовые к добавлению в репозиторий из рабочей папки


_________________________________________________________________________________________________________________________________________
ИГНОРИРОВАНИЕ ИЗМЕНЕНИЙ
имена файлов должны хранится в специальном файле .gitignore (создается вручную)
В файл .gitignore можно записывать имена файлов используя маску, например
*.log --- игнорируем все файлы проекта с расширением .log
logs/ --- игнорировать папку logs


Какие файлы не следует сохранять в репозитории?
- логи
- пользовательские файлы (аватарки, загруженные файлы, контент и-нет магазина)
- служебные файлы среды разработки
- внешние библиотеки
- файлы локальной конфигурации (н. файлы с настройками локального окружения)
- файлы операционной системы
- слишком большие файлы, которые не содержат програмный код

ОТРИЦАНИЕ ПАТТЕРНА
Если какой-то файл в папке игнорировать не следует, а нужно отслеживать
Например:
logs/*.log  #/ Исключаем все файлы с расширением log, лежащие в папке log
!logs/sample.log - продолжаем отслеживать sample.log, "!" - отрицание игнорирования



_________________________________________________________________________________________________________________________________________
2.2 Удалённые и локальные репозитории
git remote -v --- посмотреть путь к локальному репозиторию
git remote add origin [path]
git - название программы
remote - указание программе, что сейчас будет операция с настройками удаленных репозиториев
add - добавление новой записи в настройки
origin - название удаленного репозитория по умолчанию. (англ. "Источник", "Начало")
git push -u origin master --- отправляет локальный репозиторий на сервер. Параметр "-u" автоматически устанавливает связль между локальным и удаленным репозиторием таким образом, чтобы в дальнейшем можно было вызывать git push без дополнительных параметров. При первом выполнении передается имя репозитория и имя ветки (origin master)
git remote remove origin [path] --- удалит путь к удаленному репозиторию
git remote add origin [path]



_________________________________________________________________________________________________________________________________________
2.7 Внесение изменений и их отправка
git status
git add .
git commit -m 'message'
git push



_________________________________________________________________________________________________________________________________________
2.9 Обновление локального репозитория
git pull --- затянуть изменения с сервера
(!!!) Если над проектом работаете не только вы один, то всегда начинайте свою работу с команды git pull

Возможные ситуации:
1) Локальная версия == Удаленная версия (код совпадает
2) Локальная версия > Версия на сервере (локальная выше, т.е. внесены и закоммичены изменения, но не запушены на сервер)
3) Локальная версия < Версии на серверее (вы получили изменения, а затем кто-то запушил свои изменения => Версия на сервере стала выше вашей)
4) Конфликт версий (возможен, когда кто-то запушил свои изменения до вас и ваша версия локальная отличается от текущей версии на сервере)



_________________________________________________________________________________________________________________________________________
2.10 Разрешение конфликтов при обновлении репозитория
Конфликт - ситуация при которой на сервере в удаленном репозитории созданы одни коммиты, а у вас в локальном репозитории созданы другие.
Конфликты могут быть 2 видов:
- Простые --- разрешается автоматически. Примеры: изменения в разных файлах,
- Сложные --- можно разрешить только вручную (в одном файле, в одних и тех же строках)

git pull
Простой конфликт. Достаточно изменить только сообщение коммита, чтобы зафиксировать это слияние в истории изменениия
vi - редактор коммита по умолчанию. В нем можно изменить сообщение коммита
":wq" - выйти из vi. Команда сохраняет сообщение коммита
":q" - сообщение коммита по умолчанию + выход

pit push - после слияния коммитов залить новый комит со слиянием на сервер

Сложный конфликт => Нужно зайти в каждый файл, который гит не смог слить. и внести необходимые изменения. 



_________________________________________________________________________________________________________________________________________
ВЕТКИ
Позволяют работать команде над одними и теми же файлами одновременно

3.2 Ветки: создание и работа
git status - выводит в т.ч. и текущую ветку

СОЗДАТЬ ветку
git checkout -b name_of_the_branch
Параметр -b означает, что ветка новая и её нужно создать
(!) Новая ветка создается на основе текущей ветки


С помощью комманды git log можно посмотреть, в каких ветках присутствуют те или иные коммиты


ПЕРЕКЛЮЧИТЬСЯ между ветками
git checkout master --- переключение на master



_________________________________________________________________________________________________________________________________________
3.3 Работа с удалёнными ветками

Возможные кейсы:
1) Ветка создано локально,  в удаленном репозитории её нет
Решение: создать ветку с таким же именем как у локальной ветки в удаленном репозитории

git push --set-upstream origin %name-of-the-brunch%
аналогично (сокращенное написание)
git push -u origin %name-of-the-brunch%

Напоминание: origin --- имя удаленного репозитория (по умолчанию)

git remote -v --- список удаленных репозиториев, привязанных к локальному
git remote --- имя удаленного репозитория


2) Ветка есть на сервере, локально ветки нет
Решение: 
git pull

3) Ветки существуют и удаленно, и локально. Т.е. существуют и связаны
НО изменения внесены либо в одну,  либо в другую и их необходимо синхронизировать

git commit
git push

либо

git pull

___________________________
Список всех веток в репозитории:
git branch -a

зеленый цвет - локальная ветка
красный цвет - удаленный репозиторий



_________________________________________________________________________________________________________________________________________
3.5 Откладывание изменений

git stash --- сохранение внесенных изменений, которые не были закоммичены. также позволяет сохранять изменения добавленные в индексы. Сохраняются,
чтобы воспользоваться ими похже или перенести между ветками. Можно делать много наборов сохранений.
git stash list --- список наборов изменений, добавленных в stash
git stash pop --- возвращает изменения в текущую рабочую директорию. т.е. можно переключиться в другую ветку и вернуть изменния сохраненные в неё == перенос.
git stash drop N --- удаление ненужного стеша по его индексу

Принцип работы stash / stash pop

git stash ------> 0
git stash ------> 1
git stash ------> 2
git stash pop ------> 2
git stash pop ------> 1
git stash pop ------> 0



_________________________________________________________________________________________________________________________________________
3.7 Слияние веток
- свою ветку в мастер
- мастер в свою
- и т.д.
git merge имя_ветки --- (имя ветки, той, которую вливаем в текущую)



_________________________________________________________________________________________________________________________________________
3.8 Разрешение конфликтов
Конфликт - ситуация при которой Git не может слить изменения атвоматически

Наиболее частые случаи возникновения конфликтов:
- git merge
- git stash pop
- git pull
- ...

Нужно открыть в редакторе файл в котором возник конфликт
после редактирования файла
git add имя_файла
далее можно коммитить и пушить



_________________________________________________________________________________________________________________________________________
3.10 Запрос на слияние (pull request)
Запрос на слияние - запрос разработчика на слияние ветки, в которой он выполнил свою задачу, с основной (базовой) веткой проекта

GitHub === pull request
GitLab === merge request

3 способа выполнения pull request в GitHub (Соотвтетствующая вкладка + кнопка)
- Create a merge commit --- все коммиты будут добавлены к базовой ветке через merge commit, т.е. будет создан еще один обычный коммит слияния
- squash and merge --- все коммиты добавляемые к базовой ветке будут объединены в один коммит --- полезен когда разработчик создал слишком много коммитов
- rebase and merge --- перебазирование коммитов из вливаемой ветки в базовой, как-будто там они и делались. Используется для упрощения истории коммитов в проекте. Например, на большом проекте.
После этой операции можно удалить ветку из которой вливались изменения



_________________________________________________________________________________________________________________________________________
3.11 Модели ветвления

Зачем нужны модели ветвления
- Единые приницпы работы в комманде
- Быстрый deployment (публикация изменения для пользователей, выкатка в прод)

2 основные модели ветвления
1) Git Flow (flow - поток)
Приницпы:
- master ветка тщательно оборегеается от вливания непроверенных изменений
- есть ветка develop куда вливаются все изменения и проверяется общая работоспособность кода
- от develop отпачковываются ветки, в которых разрабатываются раазные фичи продукта
- есть ветка release, которая потом вливается в master. В ветку release вливаются котовые фичи
- есть ветка hotfix

2) Модель TBD (trunk based development. trunk - ствол) --- более гибкая и современная, так сказали:)
Единая ветка (master). Ветки для отдельных задач создаются на короткий срок и обычно удаляются после вливания в мастер.
В идеале, во временных ветках реализуются не задачи целеком, а их отдельные части, которые выключаются с помощью feature flags, которыми отключаются/ включаются фичи.



СРАВНЕНИЕ ВЕРСИЙ и ОТМЕНА ИЗМЕНЕНИЙ_______________________________________________________________________________________________________
4.2 Просмотр изменений
---Просмотр незакомиченных изменений
- Посмотреть изменения сделанные локально в одном файле:
git имя_файла diff
- Перечень измененных файлов по-прежнему смотрим с помощью:
git status
- Посмотреть все изменения, во всех изменных файлах:
git diff

---Просмотр изменений между коммитами
git diff хэш_коммита_более раннего хэш_коммита_более_позднего имя_файла
*можно указывать не весь хэш, а только первые 4 символа минимум


---Изменения во всем проекте между двумя коммитами
git diff хэш_коммита_более раннего хэш_коммита_более_позднего


---Можно сравнивать файлы находящиеся НЕ в git-репозитории
git diff имя_файла1 имя_файла_2

git blame <file> --- КТО и когда менял файл
ОСНОВНЫЕ КОМАНДЫ
git log
git status
git diff <file>
git diff
git diff <commit>
git diff <commit1> <commit2>
git diff <commit1> <commit2> <file>
git diff <file1> <file2>
git blame <file>




_________________________________________________________________________________________________________________________________________
4.4 Удаление незакоммиченных изменений
чтобы вернуть файл к исходному состоянию, т.е. состояние до внесенения незакоммиченных изменений, и до добавления в индекс (git add)
git resore <file>

вернуть из индекса (т.е. если выполнен git add) - отмена git add
git restore --staged <file>

удаление ВСЕХ незакомиченных изменений (во всех файлах), в том числе и добавленных в индекс
git reset --hard

удаление файлов, которые еще не отслеживаются и ни разу не добавлялись в индекс, например, новые файлы
git clean -f


удаление из отслеживания файлов, которые раньше были отслеживаемыми.
Если добавить такой файл только в .gitignore то он всё равно продолжит отслеживаться
1) Добавить в .gitignore
2) git rm --cached <file>

ОСНОВНЫЕ КОМАНДЫ
git restore <file>
git restore --staged <file>
git reset --hard
git clean -f
git rm --cached



_________________________________________________________________________________________________________________________________________
4.6 Отмена закоммиченных изменений
git checkout <commit> <file> --- возвращение в рабочую директорию файла в состоянии определенного коммита. Файл сразу добавляется в индекс.
git restore --staged <file> --- удалить файл из индекса
git revert <commit> --- отменить можно, как последний коммит, так и любой предыдущий. При этом другие коммиты не затрагиваются.
Если нужно отменить несколько коммитов, то это делается последовательным выполненем нескольких команд git revert
git revert --no-commit <commit> --- при откатывании нескольких коммитов, можно добавлять no-commit, что позволяет не делать кжадый раз коммит, а сделать потом один общий коммит


_________________________________________________________________________________________________________________________________________
4.8 Отмена (сброс) коммитов
git reset --soft <commit>  -----> удаляет коммит, возвращая его в индекс. Т.е. отправка в индекс
git reset --mixed <commit> -----> удаляет коммит, индекс. Остаются только локальные изменения. Т.е. отправка в рабочий каталог
git reset --hard <commit> -----> полностью безвозвратно удаляет последний коммит.

git commit --amend -m <new>   -----> Исправить комментарий к последнему коммиту
git commit --amend --no-edit -----> Добавляет новые изменения к последнему коммиту




_________________________________________________________________________________________________________________________________________
4.10 Отмена слияний, переименование и удаление веток
git reset --merge <commit> ---> хэш коммита должен быть ДО того коммита,  в котором происходило слияние
git merge --abort  ---> для случая, когда при слияние возник конфликт, который сложно разрулить и решено отменить мердж
git branch -m <новое название ветки>  ---> для того чтобы переименовать ветку, нужно в неё ппереключиться перед выполнением команды
git branch -d <branch>  ---> Удалить ненужную ветку. Нужно переключиться в другую ветку (не ту, которую удаляем), например, мастер
пgit branch -a   ---> Убедиться, что удаление прошло успешно